<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Enchanted Hearts</title>
  <style>
    :root{ --panel:#121225cc; --text:#f4f4ff; --muted:#c8c8e8; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:#05050b; color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      overflow:hidden; overscroll-behavior:none; touch-action:none;
    }
    .stage{ position:fixed; inset:0; background:#05050b; }
    canvas{ position:absolute; inset:0; width:100vw; height:100vh; display:block; touch-action:none; }

    .topbar{
      position:absolute; left:12px; right:12px; top:10px;
      display:flex; justify-content:space-between; align-items:center; gap:12px;
      padding:10px 12px; border-radius:16px;
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      border: 1px solid rgba(255,255,255,.10);
      backdrop-filter: blur(10px);
      pointer-events:none; opacity:.95;
    }
    .title{ font-weight:800; font-size:14px; display:flex; align-items:center; gap:8px; }
    .hint{ font-size:12px; color:var(--muted); line-height:1.25; text-align:right; }
    .kbd{
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--text); font-size: 11px; white-space:nowrap;
    }

    .overlay{
      position:absolute; inset:0;
      display:none; align-items:center; justify-content:center;
      padding:16px;
      background:
        radial-gradient(900px 520px at 50% 35%, rgba(255,95,162,.14), transparent 58%),
        radial-gradient(900px 520px at 50% 70%, rgba(139,92,246,.16), transparent 60%),
        rgba(0,0,0,.42);
      backdrop-filter: blur(6px);
    }
    .overlay.show{display:flex;}
    .panel{
      width:min(900px, 100%);
      border-radius: 22px;
      padding:16px 16px 14px;
      background: var(--panel);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 24px 70px rgba(0,0,0,.55);
    }
    .panel h2{ margin:0 0 10px; font-size: 22px; }
    .panel p{ margin:0 0 12px; color:var(--muted); line-height:1.55; font-size:14px; }
    .grid{ display:grid; grid-template-columns: 1fr 1fr; gap:10px; margin: 12px 0; }
    .card{
      border-radius: 14px; padding:10px 12px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
      color:var(--muted); font-size:13px; line-height:1.35;
    }
    .card b{color:var(--text)}
    .buttons{ display:flex; flex-wrap:wrap; gap:10px; margin-top: 8px; }
    button{
      cursor:pointer; border:0; padding:10px 14px; border-radius: 12px;
      color:var(--text);
      background: linear-gradient(180deg, rgba(255,95,162,.95), rgba(255,95,162,.70));
      box-shadow: 0 10px 24px rgba(255,95,162,.25);
      font-weight: 800;
    }
    button.secondary{
      background: rgba(255,255,255,.10);
      box-shadow:none;
      border: 1px solid rgba(255,255,255,.12);
      font-weight: 700;
    }
    .footerline{
      margin-top: 10px;
      display:flex; gap:10px; align-items:center; justify-content:space-between;
      flex-wrap:wrap; color:var(--muted); font-size:12px;
    }
    .errorbar{
      margin-top: 10px; display:none;
      padding:10px 12px; border-radius: 14px;
      background: rgba(251,113,133,.14);
      border: 1px solid rgba(251,113,133,.25);
      color: #ffd7de; font-size: 13px; line-height:1.35;
    }
    .errorbar.show{display:block;}
  </style>
</head>
<body>
  <div class="stage">
    <canvas id="c"></canvas>

    <div class="topbar">
      <div class="title">üîÆüíñ Enchanted Hearts</div>
      <div class="hint">
        Move: hold/touch or <span class="kbd">‚Üê</span><span class="kbd">‚Üí</span> ‚Ä¢
        Jump: click/tap or <span class="kbd">Space</span> ‚Ä¢ Double-jump ‚Ä¢ Restart: <span class="kbd">Enter</span>
      </div>
    </div>

    <div id="overlay" class="overlay show" aria-hidden="false">
      <div class="panel">
        <h2 id="ovTitle">How to Play</h2>
        <p id="ovText">
          <b>Level 1:</b> 30s ‚Ä¢ <b>Level 2:</b> 40s ‚Ä¢ <b>Level 3:</b> 60s.<br><br>
          On <b>every level</b>, you can take up to <b>5</b> dark orb hits.
          On the <b>5th hit</b>, the game ends.
          Each hit removes <b>1 collected heart</b> (minimum 0) and one heart icon disappears.
          Bonuses last <b>5 seconds</b>.
        </p>

        <div class="grid">
          <div class="card">
            <b>Controls</b><br>
            ‚Ä¢ <b>Mouse/Touch:</b> hold to move toward your finger/cursor<br>
            ‚Ä¢ <b>Keyboard:</b> <span class="kbd">‚Üê</span>/<span class="kbd">‚Üí</span> to move<br>
            ‚Ä¢ <b>Jump:</b> click/tap anywhere or press <span class="kbd">Space</span><br>
            ‚Ä¢ <b>Double-jump:</b> jump again in the air
          </div>
          <div class="card">
            <b>Dark hits</b><br>
            ‚Ä¢ Each level: <b>5</b> hits max<br>
            ‚Ä¢ Hit = <b>-1 heart</b> + lose 1 heart icon<br>
            ‚Ä¢ 5th hit = <b>Game Over</b>
          </div>
          <div class="card">
            <b>Bonuses (5s)</b><br>
            ‚Ä¢ <b>Shield:</b> blocks orb hits<br>
            ‚Ä¢ <b>Speed:</b> faster movement
          </div>
          <div class="card">
            <b>Tip</b><br>
            ‚Ä¢ Keep Shield for crowded moments
          </div>
        </div>

        <div class="buttons">
          <button id="btnStart">Start</button>
          <button id="btnRules" class="secondary">Show Short Rules</button>
        </div>

        <div class="footerline">
          <span id="bestLine">Best: 0 hearts</span>
          <span>Good luck üíñ</span>
        </div>

        <div id="err" class="errorbar">
          Some images failed to load. The game will still run using simple shapes as fallback.
          Check file names match exactly (case-sensitive on GitHub Pages).
        </div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("c");
    const ctx = canvas.getContext("2d");

    const overlay = document.getElementById("overlay");
    const ovTitle = document.getElementById("ovTitle");
    const ovText  = document.getElementById("ovText");
    const btnStart = document.getElementById("btnStart");
    const btnRules = document.getElementById("btnRules");
    const errBar = document.getElementById("err");
    const bestLine = document.getElementById("bestLine");

    let W = 960, H = 540, dpr = 1, GROUND_Y = 0;

    let GRAVITY = 2100, MOVE_SPEED = 360, JUMP_V = 900;

    function recomputeJumpPhysics(){
      MOVE_SPEED = Math.max(340, Math.floor(W * 0.40));
      const usable = (GROUND_Y - 60);
      const targetJumpHeight = Math.max(240, usable * 0.45);
      GRAVITY = Math.max(1900, Math.floor(usable * 4.2));
      JUMP_V = Math.sqrt(2 * GRAVITY * targetJumpHeight);
      JUMP_V = Math.min(Math.max(JUMP_V, 780), 1400);
      GRAVITY = Math.min(Math.max(GRAVITY, 1600), 3600);
    }

    function resizeCanvas(){
      dpr = Math.min(window.devicePixelRatio || 1, 2);
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);

      canvas.width  = Math.floor(W * dpr);
      canvas.height = Math.floor(H * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const groundThickness = Math.max(78, Math.floor(H * 0.14));
      GROUND_Y = H - groundThickness;

      player.h = Math.max(92, Math.floor(H * 0.18));
      player.w = Math.max(70, Math.floor(player.h * 0.80));

      player.y = Math.min(player.y, GROUND_Y - player.h);
      if (player.y < 0) player.y = GROUND_Y - player.h;
      player.x = Math.min(player.x, W - player.w);

      recomputeJumpPhysics();
    }
    window.addEventListener("resize", resizeCanvas);

    const ASSETS = { player:"G.png", heart:"K.png", orb:"N.png", bonus:"U.png", ui:"E.png", bg1:"P.png", bg2:"F.png", bg3:"Y.png" };
    const IMG = { player:null, heart:null, orb:null, bonus:null, ui:null, bg1:null, bg2:null, bg3:null };

    function loadImage(src){
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve({ ok:true, img, src });
        img.onerror = () => resolve({ ok:false, img:null, src });
        img.src = src;
      });
    }
    async function loadAllAssets(){
      const entries = Object.entries(ASSETS);
      const results = await Promise.all(entries.map(([_, src]) => loadImage(src)));
      let failed = 0;
      for (let i=0;i<entries.length;i++){
        const key = entries[i][0];
        const r = results[i];
        if (!r.ok){ failed++; console.warn("FAILED:", key, r.src); IMG[key]=null; }
        else IMG[key] = r.img;
      }
      if (failed > 0) errBar.classList.add("show");
      else errBar.classList.remove("show");
    }

    // Timers stay 30 / 40 / 60; every level maxHits = 5 ‚úÖ
    const LEVELS = [
      { id: 1, bgKey: "bg1", timeLimit: 30, maxHits: 5, orbRate: 0.95, heartRate: 1.55, bonusRate: 0.22, maxOrbs: 12, maxBonuses: 3 },
      { id: 2, bgKey: "bg2", timeLimit: 40, maxHits: 5, orbRate: 1.15, heartRate: 1.65, bonusRate: 0.20, maxOrbs: 14, maxBonuses: 3 },
      { id: 3, bgKey: "bg3", timeLimit: 60, maxHits: 5, orbRate: 1.45, heartRate: 1.70, bonusRate: 0.18, maxOrbs: 18, maxBonuses: 3 },
    ];

    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const rand = (a,b)=>a+Math.random()*(b-a);
    function aabb(ax,ay,aw,ah,bx,by,bw,bh){
      return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
    }

    const BEST_KEY = "enchanted_hearts_best_hearts_run";
    const state = {
      mode: "MENU",
      levelIndex: 0,
      timeLeft: LEVELS[0].timeLimit,

      heartsLevel: 0,
      heartsTotal: 0,
      bestTotal: Number(localStorage.getItem(BEST_KEY) || "0"),

      hitsThisLevel: 0,

      shieldTime: 0,
      speedTime: 0,

      screenShake: 0,
      messageTime: 0,
      messageText: "",

      levelElapsed: 0,
      difficulty: 1,
    };
    bestLine.textContent = `Best: ${state.bestTotal} hearts`;

    function saveBestIfNeeded(){
      if (state.heartsTotal > state.bestTotal){
        state.bestTotal = state.heartsTotal;
        localStorage.setItem(BEST_KEY, String(state.bestTotal));
      }
      bestLine.textContent = `Best: ${state.bestTotal} hearts`;
    }

    const player = {
      x: 120, y: 0, w: 84, h: 104,
      vx: 0, vy: 0,
      onGround: true,
      stun: 0,
      jumpsLeft: 2,
      maxJumps: 2,
    };

    let hearts=[], orbs=[], bonuses=[];
    let tHeart=0, tOrb=0, tBonus=0;

    function maxJumpHeight(){ return (JUMP_V*JUMP_V)/(2*GRAVITY); }

    function spawnHeart(){
      const size = rand(Math.max(30, H*0.05), Math.max(44, H*0.065));
      const mh = maxJumpHeight();
      const topLimit = Math.max(60, GROUND_Y - mh * 0.95);
      const bottomLimit = Math.max(120, GROUND_Y - player.h - 40);
      hearts.push({ x: rand(60, W-60), y: rand(topLimit, bottomLimit), w:size, h:size, bob: rand(0, Math.PI*2) });
    }

    function spawnOrb(){
      const size = rand(Math.max(36, H*0.06), Math.max(56, H*0.085));
      const fromLeft = Math.random() < 0.5;
      const base = rand(130, 270) * state.difficulty;
      orbs.push({
        x: fromLeft ? -size : W + size,
        y: rand(90, GROUND_Y - size - 10),
        w: size, h: size,
        vx: fromLeft ? base : -base,
        vy: rand(-35, 35),
        phase: rand(0, Math.PI*2),
      });
    }

    function spawnBonus(){
      const size = rand(Math.max(34, H*0.055), Math.max(50, H*0.075));
      const type = Math.random() < 0.5 ? "SHIELD" : "SPEED";
      const mh = maxJumpHeight();
      const topLimit = Math.max(70, GROUND_Y - mh * 0.85);
      const bottomLimit = Math.max(130, GROUND_Y - player.h - 50);
      bonuses.push({ x: rand(70, W-70), y: rand(topLimit, bottomLimit), w:size, h:size, type, bob: rand(0, Math.PI*2) });
    }

    function resetSpawns(){ hearts=[]; orbs=[]; bonuses=[]; tHeart=0; tOrb=0; tBonus=0; }

    function showOverlay(title, html){
      ovTitle.textContent = title;
      ovText.innerHTML = html;
      overlay.classList.add("show");
      overlay.setAttribute("aria-hidden", "false");
      bestLine.textContent = `Best: ${state.bestTotal} hearts`;
    }
    function hideOverlay(){
      overlay.classList.remove("show");
      overlay.setAttribute("aria-hidden", "true");
    }
    function flashMessage(text, seconds){
      state.messageText = text;
      state.messageTime = seconds;
    }

    function startLevel(idx){
      state.levelIndex = idx;
      state.heartsLevel = 0;
      state.hitsThisLevel = 0;

      const L = LEVELS[idx];
      state.timeLeft = L.timeLimit;

      state.levelElapsed = 0;
      state.difficulty = 1;

      resetSpawns();
      for (let i=0;i<7;i++) spawnHeart();

      player.x = Math.max(40, W * 0.10);
      player.y = GROUND_Y - player.h;
      player.vx = 0; player.vy = 0;
      player.onGround = true;
      player.stun = 0;
      player.jumpsLeft = player.maxJumps;
    }

    function startGame(){
      state.mode = "PLAY";
      state.heartsTotal = 0;
      state.heartsLevel = 0;

      state.shieldTime = 0;
      state.speedTime = 0;

      state.screenShake = 0;
      state.messageTime = 0;
      state.messageText = "";

      startLevel(0);
      hideOverlay();
      flashMessage("Level 1!", 1.0);
    }

    function goToNextLevel(){
      if (state.levelIndex >= LEVELS.length - 1){
        state.mode = "END";
        saveBestIfNeeded();
        showOverlay(
          "Run Complete! üíñ",
          `<b>Total hearts:</b> ${state.heartsTotal}<br>
           <b>Best:</b> ${state.bestTotal}<br><br>
           Tap <b>Start</b> or press <b>Enter</b> to try again.`
        );
        return;
      }
      const next = state.levelIndex + 1;
      startLevel(next);
      flashMessage(`Level ${LEVELS[next].id}!`, 1.0);
    }

    function gameOver(reason){
      state.mode = "LOSE";
      saveBestIfNeeded();
      showOverlay(
        "Game Over üñ§",
        `${reason}<br><br>
         <b>Total hearts:</b> ${state.heartsTotal}<br>
         <b>Best:</b> ${state.bestTotal}<br><br>
         Tap <b>Start</b> or press <b>Enter</b> to restart.`
      );
    }

    // Input
    const pointer = { down:false, x:0, y:0 };
    function canvasToGameXY(evt){
      const rect = canvas.getBoundingClientRect();
      return {
        x: (evt.clientX - rect.left) * (W / rect.width),
        y: (evt.clientY - rect.top)  * (H / rect.height),
      };
    }

    function tryJump(){
      if (state.mode !== "PLAY") return;
      if (player.stun > 0) return;
      if (player.jumpsLeft <= 0) return;
      player.vy = -JUMP_V;
      player.onGround = false;
      player.jumpsLeft -= 1;
    }

    canvas.addEventListener("pointerdown", (e)=>{
      if (state.mode !== "PLAY") return;
      canvas.setPointerCapture(e.pointerId);
      pointer.down = true;
      const p = canvasToGameXY(e);
      pointer.x = p.x; pointer.y = p.y;
      tryJump();
    });
    canvas.addEventListener("pointermove", (e)=>{
      if (!pointer.down) return;
      const p = canvasToGameXY(e);
      pointer.x = p.x; pointer.y = p.y;
    });
    canvas.addEventListener("pointerup", ()=>{ pointer.down=false; });
    canvas.addEventListener("pointercancel", ()=>{ pointer.down=false; });

    const keys = new Set();
    addEventListener("keydown", (e)=>{
      const k = e.key.toLowerCase();
      keys.add(k);

      if (k === "enter" && state.mode !== "PLAY") startGame();

      if (k === " " || k === "arrowup" || k === "w"){
        e.preventDefault();
        tryJump();
      }
      if (k === "arrowleft" || k === "arrowright") e.preventDefault();
    }, { passive:false });
    addEventListener("keyup", (e)=> keys.delete(e.key.toLowerCase()));

    // HUD helpers
    function roundRect(x, y, w, h, r, fill, stroke) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    function drawBg(img){
      if (img){
        const iw = img.width, ih = img.height;
        const scale = Math.max(W/iw, H/ih);
        const dw = iw*scale, dh = ih*scale;
        ctx.drawImage(img, (W-dw)/2, (H-dh)/2, dw, dh);
      } else {
        const g = ctx.createLinearGradient(0,0,W,H);
        g.addColorStop(0, "#140a22");
        g.addColorStop(1, "#08121f");
        ctx.fillStyle = g;
        ctx.fillRect(0,0,W,H);
      }
      ctx.globalAlpha = 0.20;
      ctx.fillStyle = "black";
      ctx.fillRect(0,0,W,H);
      ctx.globalAlpha = 1;
    }

    function drawGround(){
      ctx.fillStyle = "rgba(0,0,0,.40)";
      ctx.fillRect(0, GROUND_Y, W, H-GROUND_Y);
      ctx.strokeStyle = "rgba(255,255,255,.12)";
      ctx.beginPath();
      ctx.moveTo(0, GROUND_Y+0.5);
      ctx.lineTo(W, GROUND_Y+0.5);
      ctx.stroke();
    }

    function drawSpriteOrFallback(img, x, y, w, h, kind){
      if (img){ ctx.drawImage(img, x, y, w, h); return; }
      if (kind === "player"){
        ctx.fillStyle = "rgba(255,255,255,.85)";
        ctx.fillRect(x, y, w, h);
      } else if (kind === "heart"){
        ctx.fillStyle = "rgba(255,95,162,.9)";
        ctx.beginPath();
        ctx.arc(x+w*0.35, y+h*0.40, w*0.18, 0, Math.PI*2);
        ctx.arc(x+w*0.65, y+h*0.40, w*0.18, 0, Math.PI*2);
        ctx.lineTo(x+w*0.5, y+h*0.80);
        ctx.closePath();
        ctx.fill();
      } else if (kind === "orb"){
        ctx.fillStyle = "rgba(139,92,246,.9)";
        ctx.beginPath();
        ctx.arc(x+w/2, y+h/2, Math.min(w,h)/2, 0, Math.PI*2);
        ctx.fill();
      } else if (kind === "bonus"){
        ctx.fillStyle = "rgba(52,211,153,.9)";
        ctx.beginPath();
        ctx.arc(x+w/2, y+h/2, Math.min(w,h)/2, 0, Math.PI*2);
        ctx.fill();
      }
    }

    function drawBuffPill(x,y,label,seconds){
      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(0,0,0,.35)";
      roundRect(x, y, 150, 24, 999, true, false);
      ctx.globalAlpha = 1;
      ctx.fillStyle = "rgba(255,255,255,.9)";
      ctx.font = "800 12px ui-sans-serif, system-ui";
      ctx.fillText(`${label}: ${seconds}s`, x+10, y+16);
      ctx.restore();
    }

    function drawHeartIcons(x, y, current, max){
      const size = 22;
      for (let i=0;i<max;i++){
        const alive = i < current;
        const px = x + i*(size+6);
        const py = y;

        if (IMG.ui){
          ctx.globalAlpha = alive ? 1 : 0.20;
          ctx.drawImage(IMG.ui, px, py, size, size);
          ctx.globalAlpha = 1;
        } else {
          ctx.globalAlpha = alive ? 1 : 0.20;
          ctx.fillStyle = "rgba(255,95,162,.95)";
          ctx.beginPath();
          ctx.arc(px+7, py+9, 6, 0, Math.PI*2);
          ctx.arc(px+15, py+9, 6, 0, Math.PI*2);
          ctx.lineTo(px+11, py+20);
          ctx.closePath();
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }
    }

    function drawHUD(){
      const L = LEVELS[state.levelIndex];

      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(0,0,0,.35)";
      roundRect(12, 72, 540, 138, 16, true, false);
      ctx.globalAlpha = 1;

      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "800 16px ui-sans-serif, system-ui";
      ctx.fillText(`Level: ${L.id}/3`, 24, 98);

      ctx.font = "700 14px ui-sans-serif, system-ui";
      ctx.fillStyle = "rgba(255,255,255,.85)";
      ctx.fillText(`Hearts (level): ${state.heartsLevel}`, 24, 122);
      ctx.fillText(`Hearts (total): ${state.heartsTotal}`, 24, 144);
      ctx.fillText(`Best: ${state.bestTotal}`, 24, 166);

      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "800 16px ui-sans-serif, system-ui";
      ctx.fillText(`Time: ${Math.ceil(state.timeLeft)}s`, 300, 98);

      ctx.font = "800 14px ui-sans-serif, system-ui";
      ctx.fillText(`Dark hits: ${state.hitsThisLevel}/${L.maxHits}`, 300, 122);

      // Visual hearts that disappear: remaining hits (5 -> 0)
      const livesHearts = Math.max(0, L.maxHits - state.hitsThisLevel);
      drawHeartIcons(300, 138, livesHearts, L.maxHits);

      let bx = 570, by = 78;
      if (state.shieldTime > 0) { drawBuffPill(bx, by, "Shield", Math.ceil(state.shieldTime)); by += 30; }
      if (state.speedTime  > 0) { drawBuffPill(bx, by, "Speed",  Math.ceil(state.speedTime)); }

      if (state.messageTime > 0){
        ctx.globalAlpha = clamp(state.messageTime / 1.0, 0, 1);
        ctx.fillStyle = "rgba(0,0,0,.35)";
        roundRect(W/2 - 220, 72, 440, 40, 14, true, false);
        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "800 14px ui-sans-serif, system-ui";
        ctx.textAlign = "center";
        ctx.fillText(state.messageText, W/2, 98);
        ctx.textAlign = "left";
        ctx.globalAlpha = 1;
      }

      ctx.restore();
    }

    function applyOrbHit(){
      const L = LEVELS[state.levelIndex];

      if (state.heartsTotal > 0) state.heartsTotal -= 1;
      if (state.heartsLevel > 0) state.heartsLevel -= 1;

      state.hitsThisLevel += 1;
      flashMessage(`Dark hit! -1 heart (${state.hitsThisLevel}/${L.maxHits})`, 1.0);

      if (state.hitsThisLevel >= L.maxHits){
        gameOver(`You reached 5 dark hits in Level ${L.id}.`);
      }
    }

    function update(dt){
      if (state.mode !== "PLAY") return;

      const L = LEVELS[state.levelIndex];

      state.timeLeft -= dt;
      if (state.timeLeft <= 0){
        state.timeLeft = 0;
        goToNextLevel();
        return;
      }

      state.shieldTime = Math.max(0, state.shieldTime - dt);
      state.speedTime  = Math.max(0, state.speedTime  - dt);

      state.messageTime = Math.max(0, state.messageTime - dt);
      state.screenShake = Math.max(0, state.screenShake - dt*2.4);
      player.stun = Math.max(0, player.stun - dt);

      state.levelElapsed += dt;
      const step = Math.floor(state.levelElapsed / 18);
      state.difficulty = 1 + step * 0.10;
      state.difficulty = Math.min(state.difficulty, 2.3);

      const speedMul = state.speedTime > 0 ? 1.35 : 1.0;

      // movement
      let moveDir = 0;
      if (pointer.down){
        const dx = pointer.x - (player.x + player.w/2);
        if (Math.abs(dx) > 10) moveDir = dx > 0 ? 1 : -1;
      }
      const leftK  = keys.has("arrowleft") || keys.has("a");
      const rightK = keys.has("arrowright") || keys.has("d");
      if (leftK && !rightK) moveDir = -1;
      if (rightK && !leftK) moveDir = 1;

      if (player.stun > 0) player.vx *= 0.92;
      else {
        if (moveDir !== 0) player.vx = moveDir * MOVE_SPEED * speedMul;
        else player.vx *= 0.86;
      }

      // integrate
      player.vy += GRAVITY * dt;
      player.x += player.vx * dt;
      player.y += player.vy * dt;
      player.x = clamp(player.x, 0, W - player.w);

      // ground
      if (player.y + player.h >= GROUND_Y){
        player.y = GROUND_Y - player.h;
        player.vy = 0;
        if (!player.onGround) player.jumpsLeft = player.maxJumps;
        player.onGround = true;
      } else player.onGround = false;

      // spawns
      const d = state.difficulty;
      tHeart += dt * (L.heartRate * 1.05);
      tOrb   += dt * (L.orbRate   * d);
      tBonus += dt * (L.bonusRate);

      while (tHeart >= 1){ tHeart -= 1; if (hearts.length < 28) spawnHeart(); }
      while (tOrb   >= 1){ tOrb   -= 1; if (orbs.length < L.maxOrbs) spawnOrb(); }
      while (tBonus >= 1){ tBonus -= 1; if (bonuses.length < L.maxBonuses) spawnBonus(); }

      for (const h of hearts) h.bob += dt * 3.2;
      for (const b of bonuses) b.bob += dt * 2.8;
      for (const o of orbs){
        o.phase += dt * 2.3;
        o.y += Math.sin(o.phase) * 22 * dt + o.vy * dt;
        o.x += o.vx * dt;
        if (o.y < 60) { o.y = 60; o.vy = Math.abs(o.vy); }
        if (o.y > GROUND_Y - o.h - 10) { o.y = GROUND_Y - o.h - 10; o.vy = -Math.abs(o.vy); }
      }

      // hearts
      for (let i=hearts.length-1;i>=0;i--){
        const h = hearts[i];
        if (aabb(player.x, player.y, player.w, player.h, h.x, h.y, h.w, h.h)){
          hearts.splice(i,1);
          state.heartsLevel += 1;
          state.heartsTotal += 1;
          flashMessage("+1 Heart!", 0.35);
        }
      }

      // bonuses (5s)
      for (let i=bonuses.length-1;i>=0;i--){
        const b = bonuses[i];
        if (aabb(player.x, player.y, player.w, player.h, b.x, b.y, b.w, b.h)){
          bonuses.splice(i,1);
          if (b.type === "SHIELD"){
            state.shieldTime = 5;
            flashMessage("Shield (5s)!", 0.8);
          } else {
            state.speedTime = 5;
            flashMessage("Speed (5s)!", 0.8);
          }
        }
      }

      // orbs
      for (let i=orbs.length-1;i>=0;i--){
        const o = orbs[i];
        if (o.x < -220 || o.x > W + 220){ orbs.splice(i,1); continue; }

        if (aabb(player.x, player.y, player.w, player.h, o.x, o.y, o.w, o.h)){
          orbs.splice(i,1);

          if (state.shieldTime > 0){
            flashMessage("Blocked!", 0.55);
          } else {
            state.screenShake = 0.9;
            player.stun = 0.35;
            applyOrbHit();
            if (state.mode !== "PLAY") return;
          }
        }
      }

      if (state.heartsTotal > state.bestTotal) state.bestTotal = state.heartsTotal;
    }

    function draw(){
      let sx=0, sy=0;
      if (state.screenShake > 0){
        const m = state.screenShake * 6;
        sx = rand(-m, m); sy = rand(-m, m);
      }

      ctx.save();
      ctx.translate(sx, sy);

      drawBg(IMG[LEVELS[state.levelIndex].bgKey] || null);
      drawGround();

      for (const h of hearts){
        const bobY = Math.sin(h.bob) * 6;
        drawSpriteOrFallback(IMG.heart, h.x, h.y + bobY, h.w, h.h, "heart");
      }
      for (const b of bonuses){
        const bobY = Math.sin(b.bob) * 6;
        drawSpriteOrFallback(IMG.bonus, b.x, b.y + bobY, b.w, b.h, "bonus");
      }
      for (const o of orbs){
        drawSpriteOrFallback(IMG.orb, o.x, o.y, o.w, o.h, "orb");
      }

      if (state.shieldTime > 0){
        ctx.globalAlpha = 0.20;
        ctx.beginPath();
        ctx.arc(player.x+player.w/2, player.y+player.h/2, Math.max(64, player.h*0.65), 0, Math.PI*2);
        ctx.fillStyle = "rgba(52,211,153,1)";
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      drawSpriteOrFallback(IMG.player, player.x, player.y, player.w, player.h, "player");
      drawHUD();

      ctx.restore();
    }

    let last = performance.now();
    function loop(now){
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    btnStart.addEventListener("click", startGame);
    btnRules.addEventListener("click", () => {
      showOverlay(
        "Quick Rules",
        `‚Ä¢ Each level: <b>5</b> dark hits max (5th hit = Game Over)<br>
         ‚Ä¢ Each hit: <b>-1 heart</b> (min 0) + one heart icon disappears<br>
         ‚Ä¢ Timers: 30s / 40s / 60s<br>
         ‚Ä¢ Bonuses last <b>5 seconds</b>`
      );
    });

    (async function boot(){
      resizeCanvas();
      player.y = GROUND_Y - player.h;

      await loadAllAssets();

      state.bestTotal = Number(localStorage.getItem(BEST_KEY) || "0");
      bestLine.textContent = `Best: ${state.bestTotal} hearts`;

      requestAnimationFrame((t)=>{ last = t; loop(t); });

      showOverlay(
        "How to Play",
        `<b>Level 1:</b> 30s ‚Ä¢ <b>Level 2:</b> 40s ‚Ä¢ <b>Level 3:</b> 60s<br><br>
         Each level allows <b>5</b> dark orb hits. On the <b>5th hit</b> ‚Üí Game Over.<br>
         Touching a dark orb removes <b>1 collected heart</b> and one heart icon disappears.<br>
         Bonuses last <b>5 seconds</b>.<br><br>
         Tap <b>Start</b> to begin.`
      );

      state.mode = "MENU";
    })();

    addEventListener("visibilitychange", () => {
      if (document.visibilityState === "hidden"){
        const currentBest = Number(localStorage.getItem(BEST_KEY) || "0");
        if (state.heartsTotal > currentBest){
          localStorage.setItem(BEST_KEY, String(state.heartsTotal));
        }
      }
    });
  </script>
</body>
</html>
